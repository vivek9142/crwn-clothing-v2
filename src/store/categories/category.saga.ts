/*
So Type Redux Saga is a library that extends upon it.
This extension of typing out generators and typing out generators is typically very 
challenging.Other than the Type Redux saga, we also need to include a macro for babble.
Now I mentioned before that we will talk about babble at the very end, but for now all we 
need to really do is just include this additional dependency.

The reason why we have typed up Saga is that we no longer need to use Redux Saga effects.
Essentially, typed Redux Saga allows us to leverage a typed version of each of these effect 
creators.The way to use them, though, is that instead of calling yield, we will now be 
calling yield star.
So the difference between yield and yield star is that yield typically yields that generator 
and you're still inside of JavaScript generator land that handles the actual execution of 
those generator functions.

Yield start is similar, but it essentially hands up off to the Redux Saga Library.
So Redux Saga is going to behave the same way, except because its Redux saga, redux saga can 
coordinate and identify what these effects are, what their return values are going to be.
Because if you remember with a saga, a saga can have multiple yield steps.
Typically with a generator, it's very difficult to determine what the output of these 
generators are because each yield is a output of the next call in the generator.

The main thing is just that you can see sagas as generators that have redux bindings 
within them.But the other thing is that Redux saga, the library becomes the thing 
that actually drives and calls the generator in order to move it forward.
But along the way, what it does is it's able to now determine the types of the values that 
come back.

The key thing that we see is that up here, it says type saga generator is not an array type 
or a string type.The compiler needs to use this option down level iteration to allow the 
iterating of iterate hours.So what we need to do is in order for our to properly parse this 
well, we need to go into our test config JSON and inside of our compiler options.
Now what we want to add is down level iteration, except we want to set it to true.
On save here, though this may not work the way that we expect it to.

If we go back to our category saga, sometimes if you hover over, you'll notice that the type 
errors have not gone away and you'll still see it.In our case, it did end up working for me.
But if it does not for you, all you need to do is go into your VScode and just close it.
Make sure you close all of your voice code, restart it.
And what happens is that the VS compiler will rerun and hopefully pick up the correct 
changes from your test config json.
It really happens when your computer is a little older and a little slower.
Sometimes the code takes a lot of resources, so as a result, the TypeScript compiler and 
the linting might be a little bit behind.
But now we see that everything is working here right away.


One will give you a call effect, which I mentioned is an effect generated by Redux saga and 
that returns you back the category array.The next is the yield of the put effect.
It does fetch categories success.Finally, we have also a put effect of batch categories 
failed.These are the three different possible yields that can come out of such categories 
async.So that is essentially what the first parameter of the generator represents.
The next one is the return value.So this is if inside of our generator function, 
we return something as a final value, which we rarely ever do inside of our generators.
So for us, that's going to be void.And then the third argument of the generator or any 
values that we pass into the next call in order for them to get passed into the subsequent 
yield calls.
*/
import { takeLatest, all, call, put } from 'typed-redux-saga';

import { getCategoriesAndDocuments } from '../../utils/firebase/firebase.utils';

import {
  fetchCategoriesSuccess,
  fetchCategoriesFailed,
} from './category.action';

import { CATEGORIES_ACTION_TYPES } from './category.types';

export function* fetchCategoriesAsync() {
  try {
    const categoriesArray = yield* call(getCategoriesAndDocuments, 'categories');
    yield* put(fetchCategoriesSuccess(categoriesArray));
  } catch (error) {
    yield* put(fetchCategoriesFailed(error as Error));
  }
}

export function* onFetchCategories() {
  yield takeLatest(
    CATEGORIES_ACTION_TYPES.FETCH_CATEGORIES_START,
    fetchCategoriesAsync
  );
}

export function* categoriesSaga() {
  yield all([call(onFetchCategories)]);
}
